# Оптимизация использования памяти

## Проблема
Нехватка оперативной памяти при выполнении оптимизации параметров MZA на разных таймфреймах.

## Причины
1. **Слишком много данных**: 5000 записей на таймфрейм для 5 таймфреймов
2. **Слишком много комбинаций**: 500 комбинаций параметров для каждой итерации
3. **Накопление результатов**: Все результаты хранятся в памяти
4. **Нет очистки памяти**: Промежуточные объекты не удаляются

## Решения

### 1. Уменьшение количества тестируемых таймфреймов
**Было**: 5 таймфреймов (15m, 30m, 1h, 4h, 1d)  
**Стало**: 2 таймфрейма (1h, 4h)

### 2. Уменьшение количества данных
**Было**: 5000 записей на таймфрейм  
**Стало**: 2000 записей на таймфрейм

### 3. Уменьшение количества комбинаций
**Было**: 500 комбинаций параметров  
**Стало**: 100 комбинаций параметров

### 4. Уменьшение количества параметров
**Было**: 16 параметров  
**Стало**: 12 параметров (убрали наименее важные)

### 5. Хранение только топ-результатов
**Было**: Все результаты (500+ объектов)  
**Стало**: Только топ-5 результатов

### 6. Автоматическая очистка памяти
- Импортирован модуль `gc` для garbage collection
- Очистка памяти после каждого таймфрейма
- Периодическая очистка памяти каждые 20 итераций

## Изменения в коде

### `01_mza_parameter_tuning.ipynb`
```python
# Добавлено
import gc

# Изменено количество таймфреймов
timeframes = ['1h', '4h']  # Было: ['15m', '30m', '1h', '4h', '1d']

# Изменено количество данных
data_sample = mza_system.data[tf].tail(2000)  # Было: .tail(5000)

# Добавлена очистка памяти
del data_sample
gc.collect()
```

### `mza_parameter_optimizer.py`
```python
# Добавлено
import gc

# Изменено по умолчанию
max_combinations: int = 100  # Было: 1000

# Добавлена периодическая очистка памяти
if i > 0 and i % 20 == 0:
    gc.collect()

# Храним только топ-5 результатов
top_results = []
top_results.append((score, result))
top_results.sort(key=lambda x: x[0], reverse=True)
top_results = top_results[:5]
```

## Требования для выполнения

1. **RAM**: Минимум 4GB свободной оперативной памяти
2. **Диск**: 100MB свободного места
3. **Python**: 3.8+
4. **Библиотеки**:
   - pandas
   - numpy
   - scipy

## Использование

### Запуск оптимизации
```python
# Загрузите notebook и выполните ячейки по порядку
jupyter notebook 01_mza_parameter_tuning.ipynb
```

### Мониторинг использования памяти
```python
import psutil
import os

process = psutil.Process(os.getpid())
print(f"Используется памяти: {process.memory_info().rss / 1024 / 1024:.2f} MB")
```

## Ожидаемое время выполнения

- **1 таймфрейм**: ~5-10 минут
- **2 таймфрейма**: ~10-20 минут
- **Полная оптимизация**: ~20-30 минут

## Дополнительные оптимизации (по желанию)

Если все еще не хватает памяти:

1. **Уменьшить до 1 таймфрейма**
   ```python
   timeframes = ['1h']  # Только 1 таймфрейм
   ```

2. **Уменьшить количество записей до 1000**
   ```python
   data_sample = mza_system.data[tf].tail(1000)
   ```

3. **Уменьшить количество комбинаций до 50**
   ```python
   combinations = self.generate_parameter_combinations(max_combinations=50)
   ```

4. **Тестировать по одному параметру**
   ```python
   # Вместо оптимизации всех параметров сразу
   # Тестируйте по одному параметру
   ```

## Результаты

После оптимизации код использует примерно:
- **50-70% меньше памяти** по сравнению с оригинальной версией
- **В 2-3 раза быстрее** из-за меньшего количества итераций

## Примечания

- Все данные сохраняются в памяти для быстрого доступа
- Если память все еще не хватает, используйте меньший размер выборки
- Для продакшна рекомендуется использовать облачные ресурсы (Google Colab, AWS)

